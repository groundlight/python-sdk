# generated by datamodel-codegen:
#   filename:  public-api.yaml
#   timestamp: 2025-05-06T17:51:03+00:00

from __future__ import annotations

from dataclasses import dataclass, fields
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union


class AttrDict(dict):
    def __getattr__(self, name: str) -> Any:
        try:
            return self[name]
        except KeyError:
            raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")


@dataclass
class DataclassBaseModel():
    @classmethod
    def parse_obj(cls, obj: Any) -> None:
        # Get all field names from the dataclass
        field_names = {field.name for field in fields(cls)}
        # Filter the input data to only include fields that exist in the dataclass
        filtered_data = {}
        for k, v in obj.items():
            if k in field_names:
                if isinstance(v, dict):
                    filtered_data[k] = AttrDict(v)
                else:
                    filtered_data[k] = v
        return cls(**filtered_data)

@dataclass
class BBoxGeometry(DataclassBaseModel):
    """
    Mixin for serializers to handle data in the StrictBaseModel format
    """

    left: float
    top: float
    right: float
    bottom: float
    x: float
    y: float


@dataclass
class BBoxGeometryRequest(DataclassBaseModel):
    """
    Mixin for serializers to handle data in the StrictBaseModel format
    """

    left: float
    top: float
    right: float
    bottom: float


class BlankEnum(Enum):
    field_ = ""


@dataclass
class Condition(DataclassBaseModel):
    verb: str
    parameters: Any


@dataclass
class ConditionRequest(DataclassBaseModel):
    verb: str
    parameters: Any


@dataclass
class DetectorGroup(DataclassBaseModel):
    id: str
    name: str


@dataclass
class DetectorGroupRequest(DataclassBaseModel):
    name: str


class DetectorTypeEnum(str, Enum):
    detector = "detector"


@dataclass
class EdgeModelInfo(DataclassBaseModel):
    """
    Information for the model running on edge, including temporary presigned urls to the model binaries
    """

    model_binary_id: Optional[str] = None
    model_binary_url: Optional[str] = None
    oodd_model_binary_id: Optional[str] = None
    oodd_model_binary_url: Optional[str] = None
    pipeline_config: Optional[Any] = None
    oodd_pipeline_config: Optional[Any] = None
    predictor_metadata: Optional[Any] = None


class ImageQueryTypeEnum(str, Enum):
    image_query = "image_query"


class ModeEnum(str, Enum):
    BINARY = "BINARY"
    COUNT = "COUNT"
    MULTI_CLASS = "MULTI_CLASS"
    TEXT = "TEXT"
    BOUNDING_BOX = "BOUNDING_BOX"


@dataclass
class Note(DataclassBaseModel):
    detector_id: str
    content: Optional[str] = None
    is_pinned: Optional[bool] = None


@dataclass
class NoteRequest(DataclassBaseModel):
    content: Optional[str] = None
    is_pinned: Optional[bool] = None
    image: Optional[bytes] = None


@dataclass
class PayloadTemplate(DataclassBaseModel):
    template: str
    headers: Optional[Any] = None


@dataclass
class PayloadTemplateRequest(DataclassBaseModel):
    template: str
    headers: Optional[Any] = None


@dataclass
class ROI(DataclassBaseModel):
    """
    Mixin for serializers to handle data in the StrictBaseModel format
    """

    label: Any
    score: float
    geometry: Any


@dataclass
class ROIRequest(DataclassBaseModel):
    """
    Mixin for serializers to handle data in the StrictBaseModel format
    """

    label: str
    geometry: BBoxGeometryRequest


class ResultTypeEnum(str, Enum):
    binary_classification = "binary_classification"
    counting = "counting"
    multi_classification = "multi_classification"
    text_recognition = "text_recognition"
    bounding_box = "bounding_box"


class SnoozeTimeUnitEnum(str, Enum):
    """
    * `DAYS` - DAYS
    * `HOURS` - HOURS
    * `MINUTES` - MINUTES
    * `SECONDS` - SECONDS
    """

    DAYS = "DAYS"
    HOURS = "HOURS"
    MINUTES = "MINUTES"
    SECONDS = "SECONDS"


class StatusEnum(str, Enum):
    """
    * `ON` - ON
    * `OFF` - OFF
    """

    ON = "ON"
    OFF = "OFF"


@dataclass
class WebhookAction(DataclassBaseModel):
    url: Any
    include_image: Optional[bool] = None
    payload_template: Optional[PayloadTemplate] = None
    last_message_failed: Optional[bool] = None
    last_failure_error: Optional[str] = None
    last_failed_at: Optional[datetime] = None


@dataclass
class WebhookActionRequest(DataclassBaseModel):
    url: Any
    include_image: Optional[bool] = None
    payload_template: Optional[PayloadTemplateRequest] = None
    last_message_failed: Optional[bool] = None
    last_failure_error: Optional[str] = None
    last_failed_at: Optional[datetime] = None


class ResultType(Enum):
    binary_classification = "binary_classification"


@dataclass
class BinaryClassificationResult(DataclassBaseModel):
    label: str
    confidence: Optional[float] = None
    source: Optional[str] = None
    result_type: Optional[ResultType] = None
    from_edge: Optional[bool] = None


class ResultType2(Enum):
    counting = "counting"


@dataclass
class CountingResult(DataclassBaseModel):
    confidence: Optional[float] = None
    source: Optional[str] = None
    result_type: Optional[ResultType2] = None
    from_edge: Optional[bool] = None
    count: Optional[float] = None
    greater_than_max: Optional[bool] = None


class ResultType3(Enum):
    multi_classification = "multi_classification"


@dataclass
class MultiClassificationResult(DataclassBaseModel):
    label: str
    confidence: Optional[float] = None
    source: Optional[str] = None
    result_type: Optional[ResultType3] = None
    from_edge: Optional[bool] = None


class ResultType4(Enum):
    text_recognition = "text_recognition"


@dataclass
class TextRecognitionResult(DataclassBaseModel):
    truncated: bool
    confidence: Optional[float] = None
    source: Optional[str] = None
    result_type: Optional[ResultType4] = None
    from_edge: Optional[bool] = None
    text: Optional[str] = None


class ResultType5(Enum):
    bounding_box = "bounding_box"


@dataclass
class BoundingBoxResult(DataclassBaseModel):
    label: str
    confidence: Optional[float] = None
    source: Optional[str] = None
    result_type: Optional[Any] = None
    from_edge: Optional[bool] = None


@dataclass
class CountModeConfiguration(DataclassBaseModel):
    class_name: str
    max_count: Optional[int] = None


@dataclass
class MultiClassModeConfiguration(DataclassBaseModel):
    class_names: List[str]
    num_classes: Optional[int] = None


@dataclass
class TextModeConfiguration(DataclassBaseModel):
    value_max_length: Optional[int] = None


@dataclass
class BoundingBoxModeConfiguration(DataclassBaseModel):
    class_name: str
    max_num_bboxes: Optional[int] = None


class ChannelEnum(str, Enum):
    TEXT = "TEXT"
    EMAIL = "EMAIL"


@dataclass
class Action(DataclassBaseModel):
    channel: Any
    recipient: str
    include_image: bool


@dataclass
class ActionList(DataclassBaseModel):
    root: List[Action]


class AnnotationsRequestedEnum(str, Enum):
    BINARY_CLASSIFICATION = "BINARY_CLASSIFICATION"
    BOUNDING_BOXES = "BOUNDING_BOXES"


class EscalationTypeEnum(str, Enum):
    STANDARD = "STANDARD"
    NO_HUMAN_LABELING = "NO_HUMAN_LABELING"


class SourceEnum(str, Enum):
    INITIAL_PLACEHOLDER = "INITIAL_PLACEHOLDER"
    CLOUD = "CLOUD"
    CUST = "CUST"
    HUMAN_CLOUD_ENSEMBLE = "HUMAN_CLOUD_ENSEMBLE"
    ALG = "ALG"
    ALG_REC = "ALG_REC"
    ALG_UNCLEAR = "ALG_UNCLEAR"
    EDGE = "EDGE"


class VerbEnum(str, Enum):
    ANSWERED_CONSECUTIVELY = "ANSWERED_CONSECUTIVELY"
    ANSWERED_WITHIN_TIME = "ANSWERED_WITHIN_TIME"
    CHANGED_TO = "CHANGED_TO"
    NO_CHANGE = "NO_CHANGE"
    NO_QUERIES = "NO_QUERIES"


class Source(str, Enum):
    STILL_PROCESSING = "STILL_PROCESSING"
    CLOUD = "CLOUD"
    USER = "USER"
    CLOUD_ENSEMBLE = "CLOUD_ENSEMBLE"
    ALGORITHM = "ALGORITHM"
    EDGE = "EDGE"


class Label(str, Enum):
    YES = "YES"
    NO = "NO"
    UNCLEAR = "UNCLEAR"


@dataclass
class AllNotes(DataclassBaseModel):
    """
    Serializes all notes for a given detector, grouped by type as listed in UserProfile.NoteCategoryChoices
    The fields must match whats in USERPROFILE.NoteCategoryChoices
    """

    CUSTOMER: List[Note]
    GL: List[Note]

@dataclass
class Detector(DataclassBaseModel):
    """
    Groundlight Detectors provide answers to natural language questions about images.

    Each detector can answer a single question, and multiple detectors can be strung together for
    more complex logic. Detectors can be created through the create_detector method, or through the
    create_[MODE]_detector methods for pro tier users
    """

    id: str
    type: DetectorTypeEnum
    created_at: datetime
    name: str
    query: str
    group_name: str
    confidence_threshold: float
    patience_time: float
    mode: str
    metadata: Optional[Any] = None
    mode_configuration: Optional[Any] = None
    status: Optional[Any] = None
    escalation_type: Optional[str] = None


@dataclass
class DetectorCreationInputRequest(DataclassBaseModel):
    """
    Helper serializer for validating POST /detectors input.
    """

    name: str
    query: str
    confidence_threshold: float
    patience_time: float
    mode: Any
    group_name: Optional[str] = None
    pipeline_config: Optional[str] = None
    metadata: Optional[str] = None
    mode_configuration: Optional[Any] = None


@dataclass
class ImageQuery(DataclassBaseModel):
    """
    ImageQuery objects are the answers to natural language questions about images created by detectors.
    """

    id: str
    type: ImageQueryTypeEnum
    created_at: datetime
    query: str
    detector_id: str
    result_type: ResultTypeEnum
    patience_time: float
    confidence_threshold: float
    metadata: Optional[Any] = None
    result: Optional[Any] = None
    rois: Optional[List[ROI]] = None
    text: Optional[str] = None
    done_processing: bool = False


@dataclass
class LabelValue(DataclassBaseModel):
    created_at: datetime
    source: str
    confidence: Optional[float]
    class_name: Optional[str]
    annotations_requested: List[str]
    rois: Optional[List[ROI]] = None
    detector_id: Optional[int] = None
    text: Optional[str] = None


@dataclass
class LabelValueRequest(DataclassBaseModel):
    image_query_id: str
    label: Optional[str] = None
    rois: Optional[List[ROIRequest]] = None


@dataclass
class PaginatedDetectorList(DataclassBaseModel):
    count: int
    results: List[Detector]
    next: Optional[Any] = None
    previous: Optional[Any] = None


@dataclass
class PaginatedImageQueryList(DataclassBaseModel):
    count: int
    results: List[ImageQuery]
    next: Optional[Any] = None
    previous: Optional[Any] = None


@dataclass
class PatchedDetectorRequest(DataclassBaseModel):
    """
    Groundlight Detectors provide answers to natural language questions about images.

    Each detector can answer a single question, and multiple detectors can be strung together for
    more complex logic. Detectors can be created through the create_detector method, or through the
    create_[MODE]_detector methods for pro tier users
    """

    name: Optional[str] = None
    confidence_threshold: float = 0.9
    patience_time: float = 30.0
    status: Optional[Union[StatusEnum, BlankEnum]] = None
    escalation_type: Optional[str] = None


@dataclass
class Rule(DataclassBaseModel):
    id: int
    detector_id: str
    detector_name: str
    name: str
    condition: Condition
    enabled: bool = True
    snooze_time_enabled: bool = False
    snooze_time_value: int = 0
    snooze_time_unit: SnoozeTimeUnitEnum = "DAYS"
    human_review_required: bool = False
    action: Optional[Union[Action, ActionList]] = None
    webhook_action: Optional[List[WebhookAction]] = None


@dataclass
class RuleRequest(DataclassBaseModel):
    name: str
    condition: ConditionRequest
    enabled: bool = True
    snooze_time_enabled: bool = False
    snooze_time_value: int = 0
    snooze_time_unit: SnoozeTimeUnitEnum = "DAYS"
    human_review_required: bool = False
    action: Optional[Union[Action, ActionList]] = None
    webhook_action: Optional[List[WebhookActionRequest]] = None


@dataclass
class PaginatedRuleList(DataclassBaseModel):
    count: int
    results: List[Rule]
    next: Optional[Any] = None
    previous: Optional[Any] = None
